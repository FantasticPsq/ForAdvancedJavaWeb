### `HashMap`实现原理 ###
1. 首先看一下数组和链表的各自的优缺点：
```text
数组：
    1. 存储空间是连续的，且占用内存严重，空间复杂度也很大，时间复杂度为O(1)
    2. 优点：随机读取效率很高，原因是数组连续（随机访问性强，查找速度快）
    3. 缺点：插入和删除数据效率低，因为插入数据，这个位置后面的数据在内存中要往后
    移动，且大小固定不容易动态拓展。
链表：
    1. 区间离散，占用内存宽松，空间复杂度小，时间复杂度为O(N)
    2. 优点：插入删除快，内存利用率高，大小不固定，拓展灵活。
    3. 缺点：不能随机查找，查询速度慢。
```
2. 哈希表满足查询效率高且插入删除效率也高

3. map.put(k,v)实现原理：
```text
    1.先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的小标。
    2.通过上一步哈希算法转换成数组的下标之后，再通过数组下标快速定位到某个
    位置上。如果这个位置上什么都没有，则返回null。如果这个位置上单向链表，那么
    它就会拿着参数k和链表上每个节点的k进心equals。如果所有的equals方法返回
    都是false, 那么这个新的节点将被添加到链表的末尾。如果有一个equals返回了
    true,那么这个节点的值value将被覆盖。
```
    
4. map.get(k)实现原理
```text
    1. 先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标
    2. 得到数组下标之后，再通过数组下标进行定位。如果这个位置上什么也没有，则返回
    null。如果这个位置上有单向链表，那么他就会拿着参数k和单向链表上的每一个节点的k
    进行equals,如果所有的equals方法都返回false,则get方法返回nullk。如果有
    节点的k和参数k进行equals返回了true,那么此时该节点的value就是我们要找的value了。
```

5. HashMap查询在数组上，插入删除在链表上，效率都比较高   
HashMap集合的key,会先后调用两个方法，hashCode和equals方法，这两个方法都需要重写。

6. 为什么放在hashMap集合key部分的元素需要重写equals方法？   
    因为equals方法默认比较的是两个对象内存地址

7. HashMap特性
```text
    1.无序。为什么是无序的？因为不一定挂到一个单向链表上，因此
    加入顺序和取出顺序也不一样。
    2.不可重复。使用了equals方法来保证HashMap集合的key是不可重复的，如果key
    重复，那么value就会被覆盖。存放在HashMap集合key部分的元素，其实就是存放在
    HashSet中，则HashSet集合也需要重写equals和hashCode方法。
    3.HashMap集合的默认初始化容量为16，默认加载因子为0.75，也就是说这个默认加载
    因子是当HashMap集合底层数组的容量达到75%是，数组就开始扩容,HashMap集合初始化
    容量是2的倍数，这是为了达到散列均匀，提高HashMap的存取效率。
```

8. JDK8新特性
    1.JDK8之后，如果哈希表单向链表中的元素超过8个，那么单向链表会把这种数据结构变成   
    红黑树数据结构。当红黑树上的节点数量小于6个，会重新把红黑树变成单向链表。

9. 如果O1和O2的hash值相同，就会存放在同一个单向链表，如果不同，但由于哈希算法执行结束    
后转换的数组下标可能相同，此时会发生“哈希碰撞”。